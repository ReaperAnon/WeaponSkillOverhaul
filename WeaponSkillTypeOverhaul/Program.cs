using System;
using Mutagen.Bethesda;
using Mutagen.Bethesda.Synthesis;
using Mutagen.Bethesda.Skyrim;
using System.Threading.Tasks;
using Noggog;
using Mutagen.Bethesda.FormKeys.SkyrimSE;

namespace WeaponSkillTypeOverhaul
{
    public class Program
    {
        private static Lazy<Settings> _settings = null!;
        public static Settings Settings => _settings.Value;
        
        public static async Task<int> Main(string[] args)
        {
            return await SynthesisPipeline.Instance
                .AddPatch<ISkyrimMod, ISkyrimModGetter>(RunPatch)
                .SetAutogeneratedSettings("Settings", "settings.json", out _settings)
                .AddRunnabilityCheck(AssertModPresent)
                .SetTypicalOpen(GameRelease.SkyrimSE, "WSTOverhaul.esp")
                .Run(args);
        }

        public static void AssertModPresent(IRunnabilityState state)
        {
            if(Settings.MoveDualWieldPerks)
                state.LoadOrder.AssertListsMod("metaSkillMenu.esp", "The option to move dual wield perks to their own custom skill tree is active, but the required Custom Skills Menu mod is not present in the load order.\n\n\n");
        }

        public static void RunPatch(IPatcherState<ISkyrimMod, ISkyrimModGetter> state)
        {
            // If there are no new keyword definitions to generate from.
            if (!Categories.GenerateWeaponData(state))
                throw new Exception("No weapon type assignments were found. Make sure to add types to assign which can receive definitions.");

            // Assign the newly generated keywords to the weapons they match with.
            Categories.AssignWeaponTypes(state);

            // Replace weapon skill names.
            if (!Skyrim.ActorValueInformation.AVOneHanded.TryResolve(state.LinkCache, out var oneHandedGetter))
                throw new Exception("One handed skill entry not found. Patching will abort.");
            if (!Skyrim.ActorValueInformation.AVTwoHanded.TryResolve(state.LinkCache, out var twoHandedGetter))
                throw new Exception("Two handed skill entry not found. Patching will abort.");

            ActorValueInformation oneHanded = state.PatchMod.ActorValueInformation.GetOrAddAsOverride(oneHandedGetter);
            ActorValueInformation twoHanded = state.PatchMod.ActorValueInformation.GetOrAddAsOverride(twoHandedGetter);
            oneHanded.Name!.String = Settings.SkillNameOneHanded ?? oneHanded.Name.String;
            twoHanded.Name!.String = Settings.SkillNameTwoHanded ?? twoHanded.Name.String;
            oneHanded.Abbreviation = Settings.SkillAbbrvOneHanded ?? oneHanded.Abbreviation;
            twoHanded.Abbreviation = Settings.SkillAbbrvTwoHanded ?? twoHanded.Abbreviation;

            Text.BuildTextDictionary(state);
            Text.ReplaceText(oneHanded.Description, text => oneHanded.Description = text, isSkillDesc: true);
            Text.ReplaceText(twoHanded.Description, text => twoHanded.Description = text, isSkillDesc: true);

            foreach (var perkGetter in state.LoadOrder.PriorityOrder.WinningOverrides<IPerkGetter>())
            {
                var wasChanged = false;
                var perkEntry = perkGetter.DeepCopy();

                if(Categories.IsDualWieldPerk(perkEntry, state.LinkCache))
                    continue;

                wasChanged |= Perks.ReplacePerkConditions(perkEntry);
                wasChanged |= Text.ReplaceText(perkEntry.Name, text => perkEntry.Name = text, true);
                wasChanged |= Text.ReplaceText(perkEntry.Description, text => perkEntry.Description = text);

                if (wasChanged)
                    state.PatchMod.Perks.Set(perkEntry);
            }

            Console.WriteLine("Processed perks.");
            foreach (var spellGetter in state.LoadOrder.PriorityOrder.WinningOverrides<ISpellGetter>())
            {
                var wasChanged = false;
                var spellEntry = spellGetter.DeepCopy();

                if (Categories.IsDualWieldSpell(spellEntry, state.LinkCache))
                    continue;

                wasChanged |= Perks.ReplaceSpellConditions(spellEntry);
                if (spellGetter.Type != SpellType.Spell)
                {
                    wasChanged |= Text.ReplaceText(spellEntry.Description, text => spellEntry.Description = text, true);
                    wasChanged |= Text.ReplaceText(spellEntry.Name, text => spellEntry.Name = text, true);
                }

                if (wasChanged)
                    state.PatchMod.Spells.Set(spellEntry);
            }

            Console.WriteLine("Processed spells.");
            foreach (var mgefGetter in state.LoadOrder.PriorityOrder.WinningOverrides<IMagicEffectGetter>())
            {
                var wasChanged = false;
                var mgef = mgefGetter.DeepCopy();

                if (Categories.IsDualWieldMGEF(mgef))
                    continue;

                wasChanged |= Perks.ReplaceMGEFConditions(mgef);
                wasChanged |= Text.ReplaceText(mgef.Description, text => mgef.Description = text, true);
                wasChanged |= Text.ReplaceText(mgef.Name, text => mgef.Name = text, true);

                if (wasChanged)
                    state.PatchMod.MagicEffects.Set(mgef);
            }
            Console.WriteLine("Processed magic effects.");

            if (!Settings.ModifySkillTypes)
                return;

            Perks.ReplaceAnimationConditions(state.PatchMod, state.LinkCache);
            Console.WriteLine("Processed animation conditions.");

            if (Settings.MoveDualWieldPerks)
                Perks.CreatePerkTree(state);

            Perks.RemoveDualWieldConnections(state);
            Perks.ReplaceDualWieldConditions(state);
        }
    }
}
